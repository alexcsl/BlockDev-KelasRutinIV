{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_30-72ddabe240dd52c3f590a752548f63b88436904e",
  "solcVersion": "0.8.30",
  "solcLongVersion": "0.8.30+commit.73712a01",
  "userSourceNameMap": {
    "contracts/GardenToken.sol": "project/contracts/GardenToken.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "prague",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/GardenToken.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.30;\n\n// Interface for PlantNFT integration\ninterface IPlantNFT {\n    function getPlant(uint256 tokenId) external view returns (\n        uint256 id,\n        uint8 growthStage,\n        address owner,\n        uint8 rarity,\n        uint256 plantedDate,\n        uint256 lastWatered,\n        bool isAlive,\n        bool harvested\n    );\n}\n\ncontract GardenToken{\n    // disini kita masukin meta datanya\n\n    string public constant NAME = \"Garden Token\";\n    string public constant SYMBOL = \"GDN\";\n    uint8 public constant DECIMALS = 18;\n\n\n    mapping(address => uint256) public balances;\n    mapping(address => mapping(address => uint256)) public allowances;\n    uint256 public totalSupply;\n\n\n    address public owner;\n    address public gameContract;\n    address public plantNFTAddress;\n    IPlantNFT public plantNFT;\n    bool public paused;\n\n\n    // SUPPLY MANAGEMENT\n    uint256 public constant MAX_SUPPLY = 100_000_000 * 10 **18;\n\n    // REWARD SYSTEM\n    mapping(uint256 => uint256) public dailyMintedAmount;\n    uint256 public constant MAX_DAILY_MINT = 10_000 * 10**18;\n\n\n    // BURN MECHANISM\n    uint256 public totalBurned;\n    mapping(address => uint256) public lastBurnTime;\n    uint256 public constant BURN_COOLDOWN = 1 days;\n\n\n\n\n    // kita buat events yang akan terjadi\n    event Transfer(address indexed from , address indexed to, uint256 value);\n    event Approval(address indexed from , address indexed spender , uint256 value);\n    event GameContractSet(address indexed gameContract);\n    event PlantNFTSet(address indexed plantNFT);\n    event Paused(address account);\n    event UnPaused(address account);\n    event RewardMinted(address indexed player, uint256 amount, uint8 rarity, uint256 stage);\n    event TokensBurned(address indexed burner, uint256 amount, uint256 totalBurned);\n    event DailyMintLimitReached(uint256 day, uint256 amount);\n\n\n    // disini kita buat function untuk pengubahan\n    modifier onlyOwner(){\n        require(msg.sender == owner , \"Only Owner\");\n        _;\n    }\n\n    modifier onlyGameContract(){\n        require(msg.sender == gameContract , \"Only game contract\");\n        _;\n    }\n\n    modifier whenNotPaused(){\n        require(!paused, \"Contract is paused\");\n        _;\n    }\n\n    //constructor buat initialize awal2\n\n    constructor(uint256 _initTotalSupply){\n        owner = msg.sender;\n        paused = false;\n\n        balances[msg.sender] = _initTotalSupply;\n        totalSupply = _initTotalSupply;\n\n        emit Transfer(address(0), msg.sender, _initTotalSupply);\n    }\n\n    // Admin function \n\n    function setGameContract(address _gameContract) external onlyOwner{\n        require(_gameContract != address(0), \"Invalid address\");\n        gameContract = _gameContract;\n        emit GameContractSet(_gameContract);\n    }\n    \n    function setPlantNFT(address _plantNFTAddress) external onlyOwner {\n        require(_plantNFTAddress != address(0), \"Invalid address\");\n        plantNFTAddress = _plantNFTAddress;\n        plantNFT = IPlantNFT(_plantNFTAddress);\n        emit PlantNFTSet(_plantNFTAddress);\n    }\n\n    function pause() external onlyOwner(){\n        paused = true;\n        emit Paused(msg.sender);\n    }\n    function unpause() external onlyOwner(){\n        paused = false;\n        emit UnPaused(msg.sender);\n    }\n\n    // kita tambahkan view functions nya\n    function name() public pure returns (string memory){\n        return NAME;\n    }\n\n    function symbol() public pure returns (string memory){\n        return SYMBOL;\n    }\n\n    function decimals() public pure returns (uint8){\n        return DECIMALS;\n    }\n\n    function balanceOf(address account) public view returns(uint256){\n        return balances[account];\n    }\n\n    function allowance(address _owner , address _spender) public view returns(uint256){\n        return allowances[_owner][_spender];\n    }\n\n    function circulatingSupply() public view returns (uint256){\n        return totalSupply - balances[address(this)];\n    }\n    \n    function burnRate() public view returns (uint256) {\n        if (totalSupply == 0) return 0;\n        // Return burn rate as percentage with 2 decimal places (basis points)\n        // totalBurned / (totalSupply + totalBurned) * 10000\n        uint256 totalEverMinted = totalSupply + totalBurned;\n        return (totalBurned * 10000) / totalEverMinted;\n    }\n\n\n\n\n\n    // transfer function for the coins\n\n    function transfer(address _to , uint256 _amount) public whenNotPaused() returns (bool){\n        require(balances[msg.sender] >= _amount , \"Insufficient balance\");\n        require(_to != address(0), \"Invalid recipient\");\n\n        balances[msg.sender] -= _amount;\n        balances[_to] += _amount;\n\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n    function approve(address _spender, uint256 amount) public whenNotPaused() returns (bool){\n        require(_spender != address(0) , \"Invalid spender\" );\n\n        allowances[msg.sender][_spender] = amount;\n        emit Approval(msg.sender, _spender, amount);\n\n\n        return true;\n    }\n\n\n    function transferFrom(address _from , address _to , uint256 _value) public whenNotPaused() returns (bool){\n        require(balances[_from] >= _value , \"Insufficient balance\" );\n        require(allowances[_from][msg.sender] >= _value , \"Insufficient allowances\");\n        require(_to != address(0) , \"Invalid recipient\");\n        balances[_from] -= _value;\n        balances[_to] += _value;\n        allowances[_from][msg.sender] -= _value;\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    // REWARD SYSTEM\n    /**\n     * Calculate reward based on plant rarity & growth stage\n     *\n     * Formula:\n     * Base reward = 10 GDN\n     * Rarity multiplier:\n     *   - Common (1): 1x\n     *   - Rare (2): 2x\n     *   - Epic (3): 3x\n     *   - Legendary (4): 5x\n     *   - Mythic (5): 10x\n     * Growth stage multiplier:\n     *   - Seed (0): 0x (no reward)\n     *   - Sprout (1): 0.5x\n     *   - Growing (2): 0.75x\n     *   - Mature (3): 1x\n     */\n    function calculateReward(uint8 rarity, uint256 growthStage)\n        public\n        pure\n        returns (uint256)\n    {\n        // No reward for seed stage\n        if (growthStage == 0) {\n            return 0;\n        }\n        \n        uint256 baseReward = 10 * 10**18; // 10 GDN base\n        \n        // Rarity multiplier\n        uint256 rarityMultiplier;\n        if (rarity == 1) {\n            rarityMultiplier = 1; // Common\n        } else if (rarity == 2) {\n            rarityMultiplier = 2; // Rare\n        } else if (rarity == 3) {\n            rarityMultiplier = 3; // Epic\n        } else if (rarity == 4) {\n            rarityMultiplier = 5; // Legendary\n        } else if (rarity == 5) {\n            rarityMultiplier = 10; // Mythic\n        } else {\n            rarityMultiplier = 1; // Default to Common\n        }\n        \n        // Growth stage multiplier\n        uint256 stageMultiplier;\n        if (growthStage == 1) {\n            stageMultiplier = 50; // 0.5x (50/100)\n        } else if (growthStage == 2) {\n            stageMultiplier = 75; // 0.75x (75/100)\n        } else if (growthStage == 3) {\n            stageMultiplier = 100; // 1x (100/100)\n        } else {\n            stageMultiplier = 100; // Default to 1x\n        }\n        \n        return (baseReward * rarityMultiplier * stageMultiplier) / 100;\n    }\n    \n    // Internal function to get plant data and calculate reward\n    function _calculatePlantReward(uint256 plantId) internal view returns(uint256){\n        require(plantNFTAddress != address(0), \"PlantNFT not set\");\n        \n        // Get plant data from NFT contract\n        (\n            ,\n            uint8 growthStage,\n            ,\n            uint8 rarity,\n            ,\n            ,\n            bool isAlive,\n            bool harvested\n        ) = plantNFT.getPlant(plantId);\n        \n        require(isAlive, \"Plant is dead\");\n        require(!harvested, \"Already harvested\");\n        \n        return calculateReward(rarity, growthStage);\n    }\n    // MINT & BURN\n\n    function mintReward(address to, uint256 amount) external onlyGameContract whenNotPaused {\n        require(to != address(0), \"Invalid recipient\");\n        require(amount > 0, \"Amount must be greater than 0\");\n        \n        // Check max supply\n        require(totalSupply + amount <= MAX_SUPPLY, \"Exceeds max supply\");\n        \n        // Check daily mint limit\n        uint256 today = block.timestamp / 1 days;\n        require(dailyMintedAmount[today] + amount <= MAX_DAILY_MINT, \"Exceeds daily mint limit\");\n\n        // Update daily minted amount\n        dailyMintedAmount[today] += amount;\n        \n        // Check if daily limit reached\n        if (dailyMintedAmount[today] == MAX_DAILY_MINT) {\n            emit DailyMintLimitReached(today, MAX_DAILY_MINT);\n        }\n        \n        // Mint tokens\n        balances[to] += amount;\n        totalSupply += amount;\n        \n        emit Transfer(address(0), to, amount);\n    }\n    \n    // Function to mint reward for specific plant (using internal calculation)\n    function mintPlantReward(address to, uint256 plantId, uint8 rarity, uint256 growthStage) external onlyGameContract whenNotPaused {\n        require(to != address(0), \"Invalid recipient\");\n        \n        uint256 rewardAmount = calculateReward(rarity, growthStage);\n        require(rewardAmount > 0, \"No reward for this plant\");\n        \n        // Check max supply\n        require(totalSupply + rewardAmount <= MAX_SUPPLY, \"Exceeds max supply\");\n        \n        // Check daily mint limit\n        uint256 today = block.timestamp / 1 days;\n        require(dailyMintedAmount[today] + rewardAmount <= MAX_DAILY_MINT, \"Exceeds daily mint limit\");\n\n        // Update daily minted amount\n        dailyMintedAmount[today] += rewardAmount;\n        \n        // Mint tokens\n        balances[to] += rewardAmount;\n        totalSupply += rewardAmount;\n        \n        emit Transfer(address(0), to, rewardAmount);\n        emit RewardMinted(to, rewardAmount, rarity, growthStage);\n    }\n    \n    // Alternative mint function for fixed amounts (admin use)\n    function mintTokens(address _to, uint256 _amount) external onlyOwner() whenNotPaused(){\n        require(_to != address(0), \"Invalid recipient\");\n        require(totalSupply + _amount <= MAX_SUPPLY, \"Exceeds max supply\");\n        \n        balances[_to] += _amount;\n        totalSupply += _amount;\n        \n        emit Transfer(address(0), _to, _amount);\n    }\n\n    /**\n     * Burn cooldown: 1 day per user\n     * Minimum burn: 10 GDN\n     * Track total burned for analytics\n     */\n    function burn(uint256 amount) public whenNotPaused {\n        uint256 minBurnAmount = 10 * 10**18; // 10 GDN minimum\n        \n        require(amount >= minBurnAmount, \"Minimum burn amount is 10 GDN\");\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        require(block.timestamp >= lastBurnTime[msg.sender] + BURN_COOLDOWN, \"Burn cooldown active\");\n\n        balances[msg.sender] -= amount;\n        totalSupply -= amount;\n        totalBurned += amount;\n        lastBurnTime[msg.sender] = block.timestamp;\n        \n        emit Transfer(msg.sender, address(0), amount);\n        emit TokensBurned(msg.sender, amount, totalBurned);\n    }\n    \n    // Keep existing burnTokens for backward compatibility\n    function burnTokens(uint256 _amount) external whenNotPaused(){\n        burn(_amount);\n    }\n    \n    // Emergency burn by owner (no cooldown)\n    function emergencyBurn(address _from, uint256 _amount) external onlyOwner(){\n        require(balances[_from] >= _amount, \"Insufficient balance\");\n        \n        balances[_from] -= _amount;\n        totalSupply -= _amount;\n        totalBurned += _amount;\n        \n        emit Transfer(_from, address(0), _amount);\n        emit TokensBurned(_from, _amount, totalBurned);\n    }\n    \n    // ANALYTICS & VIEW FUNCTIONS\n    \n    function getDailyMintedAmount(uint256 day) external view returns (uint256) {\n        return dailyMintedAmount[day];\n    }\n    \n    function getCurrentDayMintedAmount() external view returns (uint256) {\n        uint256 today = block.timestamp / 1 days;\n        return dailyMintedAmount[today];\n    }\n    \n    function getRemainingDailyMint() external view returns (uint256) {\n        uint256 today = block.timestamp / 1 days;\n        uint256 minted = dailyMintedAmount[today];\n        return minted >= MAX_DAILY_MINT ? 0 : MAX_DAILY_MINT - minted;\n    }\n    \n    function canBurn(address user) external view returns (bool) {\n        return block.timestamp >= lastBurnTime[user] + BURN_COOLDOWN;\n    }\n    \n    function getTimeUntilBurn(address user) external view returns (uint256) {\n        uint256 nextBurnTime = lastBurnTime[user] + BURN_COOLDOWN;\n        return nextBurnTime > block.timestamp ? nextBurnTime - block.timestamp : 0;\n    }\n    \n    function getTokenomics() external view returns (\n        uint256 _totalSupply,\n        uint256 _maxSupply,\n        uint256 _totalBurned,\n        uint256 _circulatingSupply,\n        uint256 _treasuryBalance\n    ) {\n        return (\n            totalSupply,\n            MAX_SUPPLY,\n            totalBurned,\n            circulatingSupply(),\n            balances[address(this)]\n        );\n    }\n\n\n\n\n}\n"
      }
    }
  }
}